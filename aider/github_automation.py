#!/usr/bin/env python3

import sys
import json
import argparse
import traceback
from pathlib import Path
import shutil
import os
import subprocess

from aider.github_commands import GitHubCommands
from aider.io import InputOutput
from aider.coders import Coder
from aider import models

def clone_repo(owner: str, repo: str, target_dir: Path, token: str) -> bool:
    """Do a shallow clone of the repository."""
    clone_url = f"https://{token}@github.com/{owner}/{repo}.git"
    try:
        # Remove target dir if it exists
        if target_dir.exists():
            shutil.rmtree(target_dir)
            
        # Do a shallow clone (depth=1)
        result = subprocess.run(
            ["git", "clone", "--depth=1", clone_url, str(target_dir)],
            capture_output=True,
            text=True,
            check=True
        )
        return True
    except subprocess.CalledProcessError as e:
        print(f"Error cloning repository: {e.stderr}")
        return False

def process_issue_real(
    owner: str,
    repo: str,
    issue_number: int,
    work_dir: Path,
    model_name: str,
    verbose: bool = False,
    with_comments: bool = True,
) -> dict:
    """Process a GitHub issue using aider. Like run_test_real in benchmark.py."""
    # Setup working directory
    issue_dir = work_dir / f"{owner}-{repo}-{issue_number}"
    if not issue_dir.exists():
        print(f"Not a dir: {issue_dir}")
        return

    issue_dir = Path(issue_dir)
    history_fname = issue_dir / ".aider.chat.history.md"
    results_fname = issue_dir / ".aider.results.json"

    # Check for existing results
    if results_fname.exists():
        try:
            res = json.loads(results_fname.read_text())
            return res
        except json.JSONDecodeError:
            print(f"{results_fname} failed to parse, redoing...")

    # Initialize aider components
    io = InputOutput(
        pretty=True,
        yes=True,
        chat_history_file=history_fname
    )
    
    main_model = models.Model(model_name)
    
    coder = Coder.create(
        main_model,
        main_model.edit_format,
        io,
        use_git=True,  # Need git for PR creation
        stream=False,
        verbose=verbose,
        cache_prompts=True,
        suggest_shell_commands=False,
    )
    
    commands = GitHubCommands(io, coder)
    commands._ensure_client()

    try:
        # Clone repository
        repo_dir = issue_dir / "repo"
        if not clone_repo(owner, repo, repo_dir, commands.client.token):
            raise Exception("Failed to clone repository")

        # Change to repo directory for git operations
        os.chdir(repo_dir)
        
        # Create branch for this issue
        branch_name = f"fix-issue-{issue_number}"
        subprocess.run(["git", "checkout", "-b", branch_name], check=True)
        
        # Process the issue
        commands.process_issue(owner, repo, issue_number, with_comments=with_comments)
        
        # Check if there are changes
        status = subprocess.run(["git", "status", "--porcelain"], capture_output=True, text=True, check=True)
        if not status.stdout.strip():
            print("No changes made")
            return {"success": False, "reason": "no_changes"}
            
        # Push changes
        subprocess.run(["git", "push", "origin", branch_name], check=True)
        
        # Create PR
        pr_title = f"Fix issue #{issue_number}"
        pr_body = f"Fixes #{issue_number}\n\nAutomatically generated by aider"
        pr = commands.client.create_pr(
            owner,
            repo,
            title=pr_title,
            body=pr_body,
            head=branch_name,
            base="main"
        )
        
        # Record results
        results = {
            "success": True,
            "issue_number": issue_number,
            "cost": coder.total_cost,
            "error_outputs": io.num_error_outputs,
            "user_asks": io.num_user_asks,
            "malformed_responses": coder.num_malformed_responses,
            "branch_name": branch_name,
            "pr_number": pr["number"] if pr else None,
        }
    except Exception as e:
        print(f"Error processing issue {issue_number}:")
        print(e)
        traceback.print_exc()
        
        results = {
            "success": False,
            "issue_number": issue_number,
            "error": str(e),
            "traceback": traceback.format_exc()
        }

    # Save results
    results_fname.write_text(json.dumps(results, indent=2))
    return results

def process_issue(owner: str, repo: str, issue_number: int, *args, **kwargs):
    """Wrapper for process_issue_real that handles exceptions. Like run_test in benchmark.py."""
    try:
        return process_issue_real(owner, repo, issue_number, *args, **kwargs)
    except Exception as err:
        print("=" * 40)
        print("Issue processing failed")
        print(err)
        traceback.print_exc()

        work_dir = kwargs.get("work_dir")
        if work_dir:
            issue_dir = work_dir / f"{owner}-{repo}-{issue_number}"
            results_fname = issue_dir / ".aider.results.json"
            results_fname.write_text(json.dumps({"exception": str(err)}))

def main():
    """Process GitHub issues using aider."""
    parser = argparse.ArgumentParser(description="Process GitHub issues using aider")
    parser.add_argument("repos", nargs="+", help="Repositories to process (owner/repo)")
    parser.add_argument("-l", "--labels", help="Required labels (comma separated)")
    parser.add_argument("-w", "--work-dir", default="tmp.github", help="Working directory")
    parser.add_argument("-m", "--model", default="gpt-4", help="Model to use")
    parser.add_argument("-v", "--verbose", action="store_true", help="Verbose output")

    args = parser.parse_args()

    # Parse repositories
    repo_pairs = []
    for repo in args.repos:
        try:
            owner, name = repo.split("/")
            repo_pairs.append((owner, name))
        except ValueError:
            print(f"Invalid repository format: {repo}")
            sys.exit(1)

    # Setup
    work_dir = Path(args.work_dir)
    work_dir.mkdir(exist_ok=True)
    required_labels = args.labels.split(",") if args.labels else []

    # Process each repository
    for owner, repo in repo_pairs:
        print(f"\nProcessing {owner}/{repo}...")
        
        # Initialize GitHub client to get issues
        io = InputOutput(pretty=True, yes=True)
        coder = Coder.create(
            models.Model(args.model),
            None,  # Use model's default edit format
            io,
            use_git=True,
            stream=False,
            verbose=args.verbose,
            cache_prompts=True,
            suggest_shell_commands=False,
        )
        commands = GitHubCommands(io, coder)
        commands._ensure_client()
        
        issues = commands.client.get_repo_issues(owner, repo)
        
        for issue in issues:
            # Check labels
            issue_labels = [l["name"] for l in issue["labels"]]
            if required_labels and not all(l in issue_labels for l in required_labels):
                continue

            print(f"\nProcessing issue #{issue['number']}: {issue['title']}")
            
            # Create clean working directory
            issue_dir = work_dir / f"{owner}-{repo}-{issue['number']}"
            if issue_dir.exists():
                shutil.rmtree(issue_dir)
            issue_dir.mkdir(exist_ok=True)
            
            results = process_issue(
                owner,
                repo,
                issue["number"],
                work_dir=work_dir,
                model_name=args.model,
                verbose=args.verbose
            )
            
            if results and results.get("success"):
                print(f"Successfully processed issue #{issue['number']}")
            else:
                print(f"Failed to process issue #{issue['number']}")

if __name__ == "__main__":
    main()
